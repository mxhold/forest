#!/usr/bin/env ruby
require 'io/console'

SERVER_PID_FILE = "tmp/server.pid"

class Failure < RuntimeError
end

def say(dir, script, statement)
  puts "[#{dir}] #{script}: #{statement}"
end

def npm_run(dir, script)
  say(dir, script, "starting...")
  Dir.chdir(dir) do
    if system("npm run #{script}")
      say(dir, script, "done.")
    else
      say(dir, script, "failed.")
      fail Failure.new
    end
  end
end

def fix_formatting
  puts "format: starting..."
  system("npm run format")
  case $?
  when 0
    puts "format: ok."
  when 1
    puts "format: fixed."
  else
    puts "format: error."
  end
end

def client
  npm_run("client", "check")
  npm_run("client", "build")
end

def kill_server
  return unless File.exists?(SERVER_PID_FILE)
  server_pid = File.read(SERVER_PID_FILE)
  if server_pid
    Process.kill("TERM", server_pid.to_i)
    File.delete(SERVER_PID_FILE)
  end
rescue Errno::ESRCH
  # Remove stale pid file
  File.delete(SERVER_PID_FILE)
end

def server
  npm_run("server", "check")
  npm_run("server", "build")
  kill_server
  npm_run("server", "start")
end

def quit
  kill_server
  Process.kill("TERM", 0)
  exit
end

def help
  puts "Commands:"
  puts "  f: fix formatting"
  puts "  c: build client"
  puts "  s: build & (re)start server"
  puts "  a: all"
  puts "  q: quit"
end

def handle(key)
  case key
  when "f"
    fix_formatting
  when "c"
    client
  when "s"
    server
  when "a"
    fix_formatting
    client
    server
  when "q", "\C-c", "\C-d", "\C-z"
    quit
  else
    help
  end
rescue Failure
end

help

loop do
  putc ">"
  key = STDIN.getch(min: nil, time: nil, intr: true)
  puts key
  handle(key)
end